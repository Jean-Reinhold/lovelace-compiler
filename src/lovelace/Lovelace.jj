options {
    STATIC = false;
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;
    JAVA_UNICODE_ESCAPE = false;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
}

PARSER_BEGIN(LovelaceParser)
package lovelace;

import java.io.*;
import java.util.ArrayList;
import ast.*;

public class LovelaceParser {
    public Prog parse() throws ParseException {
        return Program();
    }
}
PARSER_END(LovelaceParser)

// Ignora espaços em branco
SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
}

// Comentários de linha
SKIP : {
    < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

// Palavras reservadas (precisam vir antes dos identificadores)
TOKEN : {
    < MAIN : "main" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < LET : "let" >
    | < FLOAT : "Float" >
    | < BOOL : "Bool" >
    | < VOID : "Void" >
    | < IF : "if" >
    | < WHILE : "while" >
    | < READ : "read" >
    | < RETURN : "return" >
    | < PRINT : "print" >
    | < DEF : "def" >
    | < TRUE : "true" >
    | < FALSE : "false" >
}

// Operadores (multi-caractere antes dos de um caractere)
TOKEN : {
    < ASSIGN : ":=" >
    | < AND : "&&" >
    | < OR : "||" >
    | < EQ : "==" >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < MULT : "*" >
    | < DIV : "/" >
    | < LT : "<" >
    | < GT : ">" >
}

// Pontuação
TOKEN : {
    < LPAREN : "(" >
    | < RPAREN : ")" >
    | < SEMICOLON : ";" >
    | < COMMA : "," >
}

// Números: inteiros, decimais e notação científica
TOKEN : {
    < NUMBER : (["0"-"9"])+ ("." (["0"-"9"])+)? (["E","e"] (["+","-"])? (["0"-"9"])+)? >
}

// Identificadores: letra seguida de letras/dígitos, pode ter sublinhados
TOKEN : {
    < IDENTIFIER :
        ["a"-"z","A"-"Z"]
        (["a"-"z","A"-"Z","0"-"9"])*
        ("_" (["a"-"z","A"-"Z","0"-"9"])+)*
    >
}

// Programa: LOVELACE -> MAIN FUNC?
Prog Program():
{
    ArrayList<Fun> funcs;
    Main main;
}
{
    main = MainFunction()
    funcs = FunctionList()
    { return new Prog(main, funcs); }
}

// Lista de funções (zero ou mais)
ArrayList<Fun> FunctionList():
{
    ArrayList<Fun> funcs = new ArrayList<Fun>();
    Fun f;
}
{
    (
        f = Function()
        { funcs.add(f); }
    )*
    { return funcs; }
}

// Definição de função: def Tipo nome(params) begin ... end
Fun Function():
{
    String retorno;
    Token nome;
    ArrayList<ParamFormalFun> params = new ArrayList<ParamFormalFun>();
    ArrayList<VarDecl> vars;
    ArrayList<Comando> body;
}
{
    <DEF>
    retorno = Type()
    nome = <IDENTIFIER>
    <LPAREN>
    (
        params = ParameterList()
    )?
    <RPAREN>
    <BEGIN>
    vars = VarDecl()
    body = StatementList()
    <END>
    { return new Fun(nome.image, params, retorno, vars, body); }
}

// Função main: main() begin ... end
Main MainFunction():
{
    ArrayList<VarDecl> vars;
    ArrayList<Comando> coms;
}
{
    <MAIN>
    <LPAREN>
    <RPAREN>
    <BEGIN>
    vars = VarDecl()
    coms = StatementList()
    <END>
    { return new Main(vars, coms); }
}

// Lista de parâmetros: Tipo id, Tipo id, ...
ArrayList<ParamFormalFun> ParameterList():
{
    ArrayList<ParamFormalFun> params = new ArrayList<ParamFormalFun>();
    ParamFormalFun p;
}
{
    p = Parameter() { params.add(p); }
    (
        <COMMA>
        p = Parameter() { params.add(p); }
    )*
    { return params; }
}

// Parâmetro: Tipo identificador
ParamFormalFun Parameter():
{
    String tipo;
    Token nome;
}
{
    tipo = Type()
    nome = <IDENTIFIER>
    { return new ParamFormalFun(tipo, nome.image); }
}

// Tipos: Float, Bool ou Void
String Type():
{
    Token t;
}
{
    (
        t = <FLOAT>
        | t = <BOOL>
        | t = <VOID>
    )
    { return t.image; }
}

// Declarações de variáveis: let Tipo id; (zero ou mais)
ArrayList<VarDecl> VarDecl():
{
    ArrayList<VarDecl> vars = new ArrayList<VarDecl>();
    String tipo;
    Token id;
}
{
    (
        LOOKAHEAD(2)
        <LET>
        tipo = Type()
        id = <IDENTIFIER>
        <SEMICOLON>
        { vars.add(new VarDecl(tipo, id.image)); }
    )*
    { return vars; }
}

// Lista de comandos (zero ou mais)
ArrayList<Comando> StatementList():
{
    ArrayList<Comando> coms = new ArrayList<Comando>();
    Comando c;
}
{
    (
        LOOKAHEAD(1)
        c = Statement()
        { coms.add(c); }
    )*
    { return coms; }
}

// Comando: if, while, print, return, ou identificador (atribuição/read/chamada)
Comando Statement():
{
    Comando c;
}
{
    (
        c = IfStatement()
        | c = WhileStatement()
        | c = PrintStatement()
        | c = ReturnStatement()
        | c = IdentifierStatement()
    )
    { return c; }
}

// Comando if: if (expr) begin ... end;
CIf IfStatement():
{
    Token t;
    Exp exp;
    ArrayList<Comando> bloco;
}
{
    t = <IF>
    exp = Expression()
    <BEGIN>
    bloco = StatementList()
    <END>
    <SEMICOLON>
    { return new CIf(t.beginLine, exp, bloco); }
}

// Comando while: while (expr) begin ... end;
CWhile WhileStatement():
{
    Token t;
    Exp exp;
    ArrayList<Comando> bloco;
}
{
    t = <WHILE>
    exp = Expression()
    <BEGIN>
    bloco = StatementList()
    <END>
    <SEMICOLON>
    { return new CWhile(t.beginLine, exp, bloco); }
}

// Comando print: print expr;
CPrint PrintStatement():
{
    Token t;
    Exp exp;
}
{
    t = <PRINT>
    exp = Expression()
    <SEMICOLON>
    { return new CPrint(t.beginLine, exp); }
}

// Comando return: return EXP;
CReturn ReturnStatement():
{
    Token t;
    Exp exp = null;
}
{
    t = <RETURN>
    exp = Expression()
    <SEMICOLON>
    { return new CReturn(t.beginLine, exp); }
}

// Comando com identificador: atribuição, read ou chamada de função
Comando IdentifierStatement():
{
    Token id;
    Exp exp;
    ArrayList<Exp> args = new ArrayList<Exp>();
    Comando cmd;
}
{
    id = <IDENTIFIER>
    (
        <ASSIGN>
        (
            LOOKAHEAD(2)
            <READ> <LPAREN> <RPAREN> <SEMICOLON>
            { cmd = new CReadInput(id.beginLine, id.image); }
            |
            exp = Expression() <SEMICOLON>
            { cmd = new CAtribuicao(id.beginLine, id.image, exp); }
        )
        |
        <LPAREN> ( args = ExpressionList() )? <RPAREN> <SEMICOLON>
        { cmd = new CChamadaFun(id.beginLine, id.image, args); }
    )
    { return cmd; }
}

// EXP -> "(" EXP OP EXP ")" | FATOR
Exp Expression():
{
    Exp left, right;
    String op;
    Token t;
    ArrayList<Exp> args = new ArrayList<Exp>();
}
{
    (
        // Parenthesized binary operation: ( EXP OP EXP )
        <LPAREN>
        left = Expression()
        op = Operator()
        right = Expression()
        <RPAREN>
        { return new EOpExp(op, left, right); }
    |
        // FATOR: function call — id ( args? )
        LOOKAHEAD(2)
        t = <IDENTIFIER>
        <LPAREN>
        ( args = ExpressionList() )?
        <RPAREN>
        { return new EChamadaFun(t.image, args); }
    |
        // FATOR: variable
        t = <IDENTIFIER>
        { return new EVar(t.image); }
    |
        // FATOR: number literal
        t = <NUMBER>
        { return new EFloat(Float.parseFloat(t.image)); }
    |
        // FATOR: true
        <TRUE>
        { return new ETrue(); }
    |
        // FATOR: false
        <FALSE>
        { return new EFalse(); }
    )
}

// OP -> "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "=="
String Operator():
{
    Token t;
}
{
    ( t = <PLUS> | t = <MINUS> | t = <MULT> | t = <DIV>
    | t = <AND> | t = <OR> | t = <EQ> | t = <LT> | t = <GT> )
    { return t.image; }
}

// Lista de expressões: expr, expr, expr, ...
ArrayList<Exp> ExpressionList():
{
    ArrayList<Exp> args = new ArrayList<Exp>();
    Exp e;
}
{
    e = Expression() { args.add(e); }
    (
        <COMMA>
        e = Expression() { args.add(e); }
    )*
    { return args; }
}
